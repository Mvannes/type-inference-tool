<?php
/**
 * @copyright 2017-2018 Hostnet B.V.
 */
declare(strict_types=1);

namespace Hostnet\Component\TypeInference\Analyzer\DynamicMethod;

use Hostnet\Component\TypeInference\Analyzer\Data\AnalyzedCall;
use Hostnet\Component\TypeInference\Analyzer\Data\AnalyzedClass;
use Hostnet\Component\TypeInference\Analyzer\Data\AnalyzedFunction;
use Hostnet\Component\TypeInference\Analyzer\Data\AnalyzedFunctionCollection;
use Hostnet\Component\TypeInference\Analyzer\Data\AnalyzedReturn;
use Hostnet\Component\TypeInference\Analyzer\DynamicMethod\Tracer\Parser\Exception\TraceNotFoundException;
use Hostnet\Component\TypeInference\Analyzer\DynamicMethod\Tracer\Parser\Mapper\TracerPhpTypeMapper;
use Hostnet\Component\TypeInference\Analyzer\DynamicMethod\Tracer\Parser\Record\EntryRecord;
use Hostnet\Component\TypeInference\Analyzer\DynamicMethod\Tracer\Parser\Storage\RecordStorageInterface;
use Hostnet\Component\TypeInference\Analyzer\DynamicMethod\Tracer\Parser\TraceParser;
use Hostnet\Component\TypeInference\Analyzer\DynamicMethod\Tracer\Tracer;
use Hostnet\Component\TypeInference\Analyzer\FunctionAnalyzerInterface;
use Psr\Log\LoggerInterface;
use Psr\Log\NullLogger;
use Symfony\Component\Filesystem\Exception\IOException;
use Symfony\Component\Filesystem\Filesystem;
use Symfony\Component\Stopwatch\Stopwatch;

/**
 * Uses dynamic analysis to collect argument- and return types from functions calls
 * in a target project.
 */
final class DynamicAnalyzer implements FunctionAnalyzerInterface
{
    /**
     * Prefix used for logs outputted by this class. Name used
     * by stopwatch for this class.
     */
    private const TIMER_LOG_NAME = 'DYNAMIC_ANALYSIS';

    /**
     * @var string
     */
    private $target_project;

    /**
     * @var LoggerInterface
     */
    private $logger;

    /**
     * @var RecordStorageInterface
     */
    private $storage;

    /**
     * @var string[]
     */
    private $ignored_folders;

    /**
     * @var string
     */
    private $existing_trace;

    /**
     * @var Tracer
     */
    private $tracer;

    /**
     * @param RecordStorageInterface $storage
     * @param string[] $ignored_folders
     * @param LoggerInterface $logger
     * @param string $existing_trace
     */
    public function __construct(
        RecordStorageInterface $storage,
        array $ignored_folders,
        LoggerInterface $logger = null,
        string $existing_trace = null
    ) {
        $this->logger          = $logger ?? new NullLogger();
        $this->storage         = $storage;
        $this->ignored_folders = $ignored_folders;
        $this->existing_trace  = $existing_trace;
    }

    /**
     * Clears the inserted database records.
     */
    public function __destruct()
    {
        $this->storage->clearRecords();
    }

    /**
     * Collects {@link AnalyzedFunction} by using dynamic analysis.
     *
     * @param string $target_project
     * @return AnalyzedFunction[]
     * @throws TraceNotFoundException
     * @throws \InvalidArgumentException
     * @throws \RuntimeException
     * @throws IOException
     */
    public function collectAnalyzedFunctions(string $target_project): array
    {
        $stopwatch = new Stopwatch();
        $stopwatch->start(self::TIMER_LOG_NAME);

        $this->logger->info(self::TIMER_LOG_NAME . ': Started dynamic analysis');
        $this->target_project = $target_project;

        $this->generateTrace($target_project);
        $parser = new TraceParser(
            $target_project,
            $this->existing_trace ?? $this->tracer->getFullOutputTracePath(),
            $this->storage,
            $this->ignored_folders,
            $this->logger
        );

        $parser->parse();
        $this->removeGeneratedTraceFiles();

        $analyzed_functions = $this->mapRecordsToAnalysedFunctions();

        $this->logger->info(self::TIMER_LOG_NAME . ': Finished dynamic analysis ({time}s)', [
            'time' => round($stopwatch->stop(self::TIMER_LOG_NAME)->getDuration() / 1000, 2),
        ]);
        return $analyzed_functions;
    }

    /**
     * Uses a Tracer to generate a XDebug trace for the target project unless
     * an existing trace has been provided.
     *
     * @param string $target_project
     */
    private function generateTrace(string $target_project): void
    {
        if ($this->existing_trace !== null) {
            return;
        }

        $this->tracer = new Tracer(
            $target_project . Tracer::OUTPUT_FOLDER_NAME,
            $target_project,
            dirname(__DIR__, 3),
            $this->logger
        );

        $this->tracer->generateTrace();
    }

    /**
     * Removes the files generated by the Tracer.
     *
     * @throws IOException
     */
    private function removeGeneratedTraceFiles(): void
    {
        if ($this->tracer === null) {
            return;
        }

        $file_system = new Filesystem();
        $file_system->remove($this->tracer->getFullOutputTracePath());
        $file_system->remove($this->tracer->getFullOutputBootstrapPath());
    }

    /**
     * Takes an array of AbstractRecords and creates AnalyzedFunctions.
     * In case a record is an EntryRecord, a new AnalyzedCall is added
     * to the created AnalyzedFunction. In case the record is a ReturnRecord,
     * an AnalyzedReturn is added to the AnalyzedFunction. This results in a
     * collection containing all analyzed functions with all calls that have
     * been made to that function and types that have been returned.
     *
     * @return AnalyzedFunction[]
     * @throws \InvalidArgumentException
     */
    private function mapRecordsToAnalysedFunctions(): array
    {
        $collection = new AnalyzedFunctionCollection();

        $this->storage->loopEntryRecords(function (EntryRecord $entry, array $params, $return) use ($collection): void {
            [$namespace,
                $class_name,
                $function_name,] = TracerPhpTypeMapper::extractTraceFunctionName($entry->getFunctionName());

            $class    = new AnalyzedClass(
                $namespace,
                $class_name,
                $entry->getFunctionDeclarationFile(),
                null,
                [],
                [$function_name]
            );
            $function = new AnalyzedFunction($class, $function_name);

            $function->addCollectedArguments(new AnalyzedCall(array_map(function ($param) {
                return TracerPhpTypeMapper::toPhpType($param);
            }, $params)));

            if (null !== $return) {
                $function->addCollectedReturn(new AnalyzedReturn(TracerPhpTypeMapper::toPhpType($return)));
            }

            $collection->add($function);
        });

        return $collection->getAll();
    }
}
